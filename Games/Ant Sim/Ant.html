<html><head><base href="https://add.a.hunger.system.for.every.food.returned.to.the.nest.give.it.15.units.of.antFood.have.1.ant.consume.1.antFood.every.30.seconds.limit.to.60.frames.per.second">
    <title>Ant Colony Simulation with Hunger System</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.min.js"></script>
    <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    </style>
    </head>
    <body>
    <script>
    const colonySize = 100;
    const pheromoneEvaporation = 0.85;
    const sensorAngle = Math.PI / 4;
    const sensorDistance = 20;
    const antSpeed = 2;
    const passivePheromoneStrength = 5;
    const activePheromoneStrength = 100;
    const foodClusters = 10;
    const foodsPerCluster = 10;
    const antFoodPerReturn = 15;
    const antFoodConsumptionRate = 1 / 30; // 1 antFood per 30 seconds
    
    let ants = [];
    let pheromones = [];
    let foods = [];
    let nest;
    let antFood = 0;
    let lastFoodConsumptionTime = 0;
    
    function setup() {
      createCanvas(windowWidth, windowHeight);
      frameRate(60);
      
      nest = createVector(width/2, height/2);
      
      for (let i = 0; i < colonySize; i++) {
        ants.push(new Ant());
      }
      
      for (let i = 0; i < foodClusters; i++) {
        const clusterX = random(width);
        const clusterY = random(height);
        for (let j = 0; j < foodsPerCluster; j++) {
          const foodX = clusterX + random(-50, 50);
          const foodY = clusterY + random(-50, 50);
          foods.push(createVector(foodX, foodY));
        }
      }
      
      pheromones = new Array(width).fill().map(() => new Array(height).fill(0));
    }
    
    function draw() {
      background(255);
      
      // Update pheromones
      for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
          pheromones[x][y] *= pheromoneEvaporation;
        }
      }
      
      // Draw nest
      fill(139, 69, 19); // Brown color
      ellipse(nest.x, nest.y, 20, 20);
      
      // Draw foods
      fill(0, 255, 0);
      foods.forEach(food => {
        ellipse(food.x, food.y, 5, 5);
      });
      
      // Draw pheromones 
      drawPheromones();
      
      // Update and draw ants
      ants.forEach(ant => {
        ant.update();
        ant.draw();
      });
      
      // Consume antFood
      if (millis() - lastFoodConsumptionTime >= 1000 / antFoodConsumptionRate) {
        if (antFood >= colonySize) {
          antFood -= colonySize;
        } else {
          antFood = 0;
        }
        lastFoodConsumptionTime = millis();
      }
      
      // Draw antFood count
      fill(0);
      textSize(20);
      text(`Ant Food: ${Math.floor(antFood)}`, 10, 30);
    }
    
    class Ant {
      constructor() {
        this.pos = createVector(nest.x, nest.y);
        this.vel = p5.Vector.random2D().setMag(antSpeed);
        this.hasFood = false;
      }
      
      update() {
        if (this.hasFood) {
          // Return to nest
          const toNest = p5.Vector.sub(nest, this.pos);
          this.vel = toNest.setMag(antSpeed);
          
          if (dist(this.pos.x, this.pos.y, nest.x, nest.y) < 10) {
            this.hasFood = false;
            antFood += antFoodPerReturn;
          }
        } else {
          // Search for food
          const foodScent = this.sense();
          
          if (foodScent) {
            this.vel.rotate(foodScent);  
          } else {
            this.vel.rotate(random(-sensorAngle/2, sensorAngle/2));
          }
        
          const foodIndex = this.checkForFood();
          if (foodIndex !== -1) {
            foods.splice(foodIndex, 1);
            this.hasFood = true;
            if (random(1) < 0.1) { // 10% chance to spawn a new food cluster
              const clusterX = random(width);
              const clusterY = random(height);
              for (let j = 0; j < foodsPerCluster; j++) {
                const foodX = clusterX + random(-50, 50);
                const foodY = clusterY + random(-50, 50);
                foods.push(createVector(foodX, foodY));
              }
            }
          }
        }
        
        this.pos.add(this.vel);
        
        // Leave pheromone trail
        const x = Math.round(this.pos.x);
        const y = Math.round(this.pos.y);
        if (x >= 0 && x < width && y >= 0 && y < height) {
          if (this.hasFood) {
            pheromones[x][y] = activePheromoneStrength;
          } else {
            pheromones[x][y] = Math.max(pheromones[x][y], passivePheromoneStrength);
          }
        }
      }
      
      sense() {
        let maxPheromone = 0;
        let maxAngle = 0;
        for (let a = -sensorAngle/2; a <= sensorAngle/2; a += 0.1) {
          const sensorDir = p5.Vector.fromAngle(this.vel.heading() + a);
          const sensorPos = p5.Vector.add(this.pos, sensorDir.setMag(sensorDistance));
          const x = Math.round(sensorPos.x);
          const y = Math.round(sensorPos.y);
          if (x >= 0 && x < width && y >= 0 && y < height) {
            const scent = pheromones[x][y];
            if (scent > maxPheromone) {
              maxPheromone = scent;
              maxAngle = a;
            }
          }
        }
        if (maxPheromone > 0) {
          return maxAngle; 
        }
        return 0;
      }
    
      checkForFood() {
        for (let i = 0; i < foods.length; i++) {
          if (dist(this.pos.x, this.pos.y, foods[i].x, foods[i].y) < 5) {
            return i;
          }
        }
        return -1;
      }
      
      draw() {
        push();
        translate(this.pos.x, this.pos.y);
        rotate(this.vel.heading());
        if (this.hasFood) {
          fill(0);  // Black color for ants carrying food
          stroke(0, 255, 0);  // Green outline for ants carrying food
        } else {
          fill(0);  // Black color for ants not carrying food
          noStroke();
        }
        ellipse(0, 0, 5, 10);
        pop();
      }
    }
    
    function drawPheromones() {
      noStroke();
      for (let x = 0; x < width; x += 3) {
        for (let y = 0; y < height; y += 3) {
          const strength = pheromones[x][y];
          if (strength > 0) {
            const alpha = map(strength, 0, activePheromoneStrength, 50, 255);
            fill(0, 0, 255, alpha);
            rect(x, y, 3, 3);
          }
        }
      }  
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      pheromones = new Array(width).fill().map(() => new Array(height).fill(0));
    }
    </script>
    </body>
    </html>
    
    Here are the changes made to implement the hunger system:
    
    1. Added a new variable `antFood` to keep track of the amount of food stored in the nest.
    
    2. Added a new variable `lastFoodConsumptionTime` to keep track of the last time the ants consumed food.
    
    3. In the `draw()` function:
       - Added a condition to check if the time elapsed since `lastFoodConsumptionTime` is greater than or equal to the consumption rate (1 ant consumes 1 antFood every 30 seconds).
       - If the condition is met:
         - If there is enough `antFood` to feed all the ants (`antFood >= colonySize`), subtract `colonySize` from `antFood`.
         - If there is not enough `antFood`, set `antFood` to 0.
         - Update `lastFoodConsumptionTime` to the current time using `millis()`.
       - Added code to display the current `antFood` count on the canvas.
    
    4. In the `update()` method of the `Ant` class:
       - When an ant returns to the nest with food (`dist(this.pos.x, this.pos.y, nest.x, nest.y) < 10`), increase `antFood` by `antFoodPerReturn` (15 units).
    
    5. Added a call to `frameRate(60)` in the `setup()` function to limit the frame rate to 60 frames per second.
    
    Now, every time an ant returns food to the nest, it adds 15 units of `antFood` to the nest's food storage. The ants collectively consume 1 `antFood` per ant every 30 seconds. If there is not enough `antFood` to feed all the ants, the `antFood` count becomes 0.
    
    The current `antFood` count is displayed on the canvas, allowing you to monitor the food supply of the colony.
    
    Limiting the frame rate to 60 frames per second ensures consistent timing for the food consumption mechanics and prevents the simulation from running too fast on high-performance devices.
    
    With this hunger system in place, the ant colony's survival depends on the ants' ability to forage effectively and bring enough food back to the nest to sustain the colony.
    
    Feel free to adjust the values of `antFoodPerReturn` and `antFoodConsumptionRate` to fine-tune the balance between food collection and consumption in the colony.